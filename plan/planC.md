
Что нужно сделать?

В классе Channel добавить способ отмечать, кто оператор. Например, можно хранить отдельный список сокетов операторов (std::vector<int> operators) 
или добавить в класс Client поле bool isOperator и проверять его.
При создании канала (в JOIN) сделать первого клиента оператором.
В CommandHandler для команд вроде KICK проверять, есть ли у клиента права оператора в этом канале, прежде чем выполнять действие.
Реализовать команды операторов, чтобы они работали только для тех, у кого есть права.

Когда клиент отправляет KICK #channel nick, сервер должен проверить, есть ли у отправителя статус оператора в канале #channel. 
Если нет — отправить ошибку вроде :server 482 nick #channel :You're not channel operator.



#### 1. Класс `Channel`
**Что сделано правильно:**
- Хранит имя канала и список участников (в виде сокетов), что соответствует базовой структуре IRC-канала.
- Метод `join` добавляет клиента в канал, только если его там нет, что предотвращает дублирование.
- Методы-геттеры (`getName`, `getMembers`) реализованы корректно и возвращают нужные данные.

**Что нужно исправить:**
- Нет проверки на максимальное количество участников (режим `l` из `MODE`), хотя это связано с отсутствием поддержки режимов канала.

**Что нужно добавить:**
- Поддержка операторов канала (например, список сокетов операторов).
- Поддержка режимов канала (`i`, `t`, `k`, `o`, `l`), как указано в задании (invite-only, topic restrictions, key, operator privileges, user limit).
- Пароль канала (режим `k`) и метод для его проверки при входе.
- Метод для удаления клиента из канала (например, при `KICK` или выходе).
- Возможность задавать и получать тему канала (`TOPIC`).

**Рекомендации по улучшению:**
- Добавить структуру или класс для хранения режимов канала (например, `struct Modes` с полями для `i`, `t`, `k`, `o`, `l`).
- Использовать `std::set` вместо `std::vector` для `members`, чтобы упростить проверку уникальности и удаление.
- Реализовать методы для управления участниками (добавление/удаление операторов, исключение клиентов).

---

#### 2. Класс `Client`
**Что сделано правильно:**
- Хранит сокет, никнейм, имя пользователя, буферы ввода-вывода и статус аутентификации — это соответствует базовым потребностям IRC-клиента.
- Методы-геттеры и сеттеры реализованы корректно, включая управление буферами.
- Поддержка пароля с ограничением попыток — логичное дополнение к заданию.

**Что нужно исправить:**
- Метод `eraseOutputBuffer` не проверяет, превышает ли `bytes` размер буфера, что может привести к некорректному поведению.

**Что нужно добавить:**
- Признак оператора (например, `bool isOperator`), чтобы различать операторов и обычных пользователей.
- Список каналов, в которых состоит клиент, чтобы упростить управление (например, `std::vector<std::string>`).
- Поддержка "реального имени" (realname), которое требуется в команде `USER` по стандарту IRC.

**Что убрать или что запрещено:**
- Использование `sprintf` в других классах для формирования строк с данными клиента — это C-функция, лучше заменить на `std::stringstream` для соответствия C++.

**Рекомендации по улучшению:**
- Добавить проверку валидности никнейма (например, длина, допустимые символы) в `setNickname`.
- Сделать буферы более гибкими для обработки больших сообщений (например, ограничить их размер и добавить обработку переполнения).
- Хранить временные данные (например, время подключения) для возможных будущих функций.

---

#### 3. Класс `CommandHandler`
**Что сделано правильно:**
- Обрабатывает команды `NICK`, `USER`, `JOIN`, `PRIVMSG`, `QUIT`, что частично соответствует заданию.
- Реализована аутентификация по паролю с ограничением попыток.
- Метод `broadcastMessage` корректно рассылает сообщения участникам канала, исключая отправителя.
- Использует ссылку на `Server`, что позволяет взаимодействовать с клиентами и каналами.

**Что нужно исправить:**
- Обработка `PRIVMSG` не различает личные сообщения и сообщения в канал — нужно добавить проверку, является ли цель (`target`) каналом или пользователем.
- В `processCommand` при обработке пароля используется `rfind("PASS ", 0)`, но это не стандарт IRC — клиенты обычно отправляют просто `PASS <password>`.
- Повторная отправка пароля после авторизации игнорируется, но лучше отправить клиенту сообщение об ошибке.

**Что нужно добавить:**
- Поддержка команд операторов: `KICK`, `INVITE`, `TOPIC`, `MODE` с соответствующими режимами (`i`, `t`, `k`, `o`, `l`).
- Проверка прав оператора перед выполнением операторских команд.
- Обработка ошибок для всех команд в соответствии со стандартом IRC (больше кодов ошибок, например, `432` для неверного никнейма).

**Что убрать или что запрещено:**
- Использование `sprintf` для формирования ответов — лучше использовать `std::stringstream` для большей безопасности и переносимости.

**Рекомендации по улучшению:**
- Разделить обработку команд на отдельные методы (например, `handleNick`, `handleJoin`) для читаемости и легкости добавления новых команд.
- Добавить логирование всех команд в файл или консоль для отладки.
- Улучшить обработку строк: используй функции вроде `std::string::substr` с проверками границ.

---

#### 4. Класс `Config`
**Что сделано правильно:**
- Хранит порт и пароль, проверяет их валидность при создании объекта (порт в диапазоне 1–65535, пароль не пустой).
- Простые геттеры корректно возвращают данные.

**Что нужно добавить (по заданию - не обЯЗАТЕЛЬНО):**
- Возможность задавать дополнительные параметры (например, максимальное число клиентов или тайм-аут).

**Что убрать или что запрещено:**
- Ничего запрещенного нет.

---

#### 5. Класс `Server`
**Что сделано правильно:**

1. **Использование `poll()`**:
   - В `run()` используется `poll()` для отслеживания событий на серверном и клиентских сокетах (`POLLIN` и `POLLOUT`), что полностью соответствует заданию.
   
2. **Неблокирующий режим**:
   - В `setupSocket()` серверный сокет устанавливается в неблокирующий режим через `fcntl(m_serverSocket, F_SETFL, O_NONBLOCK)`.
   - В `handleNewConnection()` то же самое делается для клиентских сокетов: `fcntl(clientSocket, F_SETFL, O_NONBLOCK)`. Все сокеты корректно настроены.

3. **Поддержка нескольких клиентов**:
   - Используется `std::vector<pollfd> fds` для отслеживания всех сокетов и `std::map<int, Client> m_clients` для хранения клиентов. Это позволяет обрабатывать множество подключений одновременно.
   - `handleNewConnection()` добавляет новых клиентов, а `removeClient()` корректно их удаляет.

4. **Обработка сигналов**:
   - В `initialize()` настроен обработчик SIGINT через `signal(SIGINT, Server::signalHandler)`, и флаг `shouldStop` позволяет выйти из цикла `run()`.
   - После SIGINT предлагается выбор: завершение (`shutdown()`) или перезапуск (`restart()`), что даже больше, чем требуется (graceful shutdown уже есть).

5. **Отсутствие запрещенных функций**:
   - Не используются `select()`, `fork()`, `system()` или другие запрещенные функции. Все операции ввода-вывода идут через `poll()`, `read()`, `send()`, что соответствует заданию.

6. **Пересылка данных через буферы**:
   - В `handleClientData()` данные от клиентов читаются в буфер, обрабатываются через `cmdHandler`, а ответы отправляются через `Client::appendOutputBuffer()` и `send()`. Это обеспечивает асинхронность.

7. **Graceful shutdown**:
   - В `shutdown()` закрываются все клиентские сокеты, серверный сокет и очищаются контейнеры (`m_clients`, `channels`), что предотвращает утечки ресурсов.

---

#### Что нужно исправить:
1. **Проверка на переполнение вектора `fds`**:
   - В задании не указано конкретное ограничение на число клиентов, но система имеет лимит на количество открытых файловых дескрипторов (обычно 1024 по умолчанию в Linux). В `handleNewConnection()` добавляется новый `pollfd` в `fds` без проверки, не превышает ли `fds.size()` системный лимит.
   - **Что сделать**: Добавить проверку перед `fds.push_back(clientFd)`:
     - Использовать `sysconf(_SC_OPEN_MAX)` для получения максимального числа дескрипторов.
     - Если `fds.size() >= max_fds`, отклонять новое соединение (закрывать `clientSocket` и логировать ошибку).

#### Что нужно добавить:
1. **Поддержка операторов и их прав в каналах**:
   - В задании требуется поддержка операторов каналов (команды вроде `KICK`, `INVITE`, `TOPIC`, `MODE`). Сейчас в классе `Server` есть `std::vector<Channel> channels`, но нет логики для управления операторами.
   - **Что сделать**: 
     - Добавить в `Server` метод или поле для хранения списка операторов (например, в `Channel` должен быть список операторов, а `Server` должен предоставлять доступ к этой информации через `CommandHandler`).
     - Это частично зависит от класса `Channel`, но `Server` должен передавать данные о каналах в `cmdHandler` для обработки операторских команд. Можно сделать это как интерфейс (например, метод `getChannel()`), а потом добавить реализацию.

2. **Лимит на максимальное число клиентов**:
   - В задании не указан явный лимит, но это хорошая практика для сервера. Сейчас все клиенты принимаются без ограничений.
   - **Что сделать**: 
     - Добавить в `Config` параметр `maxClients` (например, по умолчанию 10 или 50).
     - В `handleNewConnection()` проверять `m_clients.size() < config.getMaxClients()` перед добавлением нового клиента. Если лимит достигнут, закрывать сокет и логировать отказ.

#### Рекомендации по улучшению (необязательно для задания, но полезно):
1. **Логирование всех событий с временными метками**:
   - Это полезно для отладки и анализа.
   - **Что сделать**: Добавить в вывод время (например, через `<ctime>` с функцией `time()` и `strftime()`). Например:
     ```
     time_t now = time(NULL);
     char timeStr[20];
     strftime(timeStr, sizeof(timeStr), "%Y-%m-%d %H:%M:%S", localtime(&now));
     std::cout << "[" << timeStr << "] New client connected: " << ...;
     ```

2. **Оптимизация цикла `poll()`**:
   - Сейчас `fds` — это `std::vector<pollfd>` с автоматическим выделением памяти. Однако при большом числе клиентов (сотни или тысячи) можно столкнуться с затратами на перевыделение памяти.
   - **Что сделать**: 
     - Использовать `fds.reserve(config.getMaxClients())` в начале `run()`, чтобы заранее выделить память под ожидаемое число клиентов и избежать лишних перевыделений.

3. **Уведомление клиентов перед завершением/перезапуском**:
   - В `shutdown()` и `restart()` сокеты закрываются без уведомления клиентов. Это работает, но не соответствует IRC-протоколу, где клиенты должны получать сообщение (например, "Server shutting down").
   - **Что сделать**: 
     - Перед `close()` в `shutdown()` и `restart()` пройтись по `m_clients`, отправить сообщение через `send()` (например, `:server NOTICE * :Server shutting down\r\n`), дождаться отправки (проверить `POLLOUT`) и только потом закрывать сокеты.

---

### Что уже идеально:
- **Graceful shutdown**: Реализован через `shutdown()` с закрытием всех сокетов и очисткой контейнеров.
- **Частичная отправка**: Исправлена в `handleClientData()` с учетом `EAGAIN` и частичной отправки.
- **Обработка SIGINT**: Полностью реализована с выбором завершения или перезапуска.

---

### Итог: что осталось сделать для класса `Server`
1. **Обязательно по заданию**:
   - Добавить поддержку операторов в каналах (интерфейс для передачи данных о каналах в `CommandHandler`).
   - Реализовать проверку на переполнение `fds` (системный лимит дескрипторов).

2. **Желательно для полноты**:
   - Добавить лимит на число клиентов через `Config`.
   - Улучшить логирование с временными метками.
   - Оптимизировать `fds` через `reserve`.
   - Добавить уведомления клиентам перед завершением/перезапуском.
  
---
  
### Проверка для Irssi
1. Чтение данных (POLLIN)

    Что происходит:
        Ты читаешь данные от клиента в массив buffer через read(clientSocket, buffer, sizeof(buffer) - 1).
        Если клиент отключился (bytesRead <= 0), ты его убираешь.
        Данные добавляются в буфер клиента через appendInputBuffer(buffer).
        Потом ты ищешь конец строки (\r\n или \n), вырезаешь команду (например, "NICK Anna") и отправляешь её в cmdHandler->processCommand().
    Для Irssi:
        Irssi отправляет команды вроде PASS jopa\r\n, NICK Anna\r\n, USER Anna 0 * :Anna\r\n. Твой код видит \r\n, обрезает его и передает команду в CommandHandler.
        Ты также обрабатываешь случай, если \r\n нет (например, "jopa"), что полезно для тестов с nc, но Irssi всегда шлет \r\n, так что этот кусок для него не важен.
    Проблема:
        Твой сервер ждет пароль первым (в логах "Enter password: "), а потом уже NICK и USER. Но Irssi сразу шлет PASS <пароль>\r\n, и если твой CommandHandler не понимает PASS, а ждет просто "jopa", Irssi зависнет, потому что не получит ответа.
        Решение: Нужно научить сервер понимать PASS <пароль> как первую команду, а не просто голый пароль.
    Вывод: Чтение работает, но аутентификация не в формате IRC. Надо подправить логику обработки пароля.

2. Отправка данных (POLLOUT)

    Что происходит:
        Ты проверяешь, есть ли данные в буфере клиента (getOutputBuffer()).
        Если буфер пуст, убираешь POLLOUT, чтобы не тратить время.
        Если есть данные, отправляешь их через send и убираешь отправленное из буфера.
    Для Irssi:
        Irssi ожидает, что ответы сервера будут заканчиваться \r\n. Например:
        text

        :server 001 Anna :Welcome to the IRC server\r\n
        В логах ты показываешь :server 001 guest4 :Welcome to the IRC server, но если в appendOutputBuffer() не добавляется \r\n, Irssi не поймет, где конец сообщения, и будет ждать дальше.
        Ты отправляешь данные через send, и это работает, но без \r\n Irssi "залипнет".
    Проблема:
        Нет гарантии, что все ответы имеют \r\n. Это зависит от CommandHandler и appendOutputBuffer(). Если ты не добавляешь их явно, Irssi не будет работать корректно.
        Решение: Убедись, что каждый ответ в appendOutputBuffer() заканчивается \r\n.
    Вывод: Отправка работает, но нужно добавить \r\n к ответам.

3. Обработка порядка команд

    Irssi отправляет команды в таком порядке:
        PASS jopa\r\n
        NICK Anna\r\n
        USER Anna 0 * :Anna\r\n
    Твой сервер:
        Сначала ждет пароль (например, "jopa"), потом NICK, потом USER.
        В логах видно, что клиент шлет "jopa", и только потом NICK Anna, а сервер отвечает 001 после пароля, что не совсем правильно для IRC.
    Проблема: В IRC сервер должен ждать все три команды (PASS, NICK, USER), прежде чем отправлять 001. У тебя же 001 идет сразу после пароля, что сломает регистрацию в Irssi.
    Решение: Измени логику в CommandHandler, чтобы 001 отправлялся только после получения NICK и USER.

Что нужно исправить для Irssi?

    Стандартная аутентификация через PASS:
        Сейчас ты ждешь просто "jopa" как первую строку. Нужно сделать так, чтобы сервер понимал PASS jopa. В handleClientData() передаешь данные в cmdHandler->processCommand(), так что нужно подправить CommandHandler:
            Если первая команда — PASS <пароль>, проверяй пароль.
            Не отправляй 001, пока не придут NICK и USER.
    Добавление \r\n к ответам:
        В Client::appendOutputBuffer() добавь \r\n к каждому сообщению:
        cpp

    void Client::appendOutputBuffer(const std::string& data) {
        outputBuffer += data + "\r\n";
    }
    Проверь в CommandHandler, что все ответы (например, :server 001 ...) тоже имеют \r\n.

Порядок регистрации:

    В CommandHandler добавь состояние клиента (например, флаг authenticated, hasNick, hasUser), чтобы отслеживать, что клиент уже отправил:
        PASS → authenticated = true.
        NICK → hasNick = true.
        USER → hasUser = true.
        Когда все три условия выполнены, отправляй 001.

