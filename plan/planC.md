
Что нужно сделать?

В классе Channel добавить способ отмечать, кто оператор. Например, можно хранить отдельный список сокетов операторов (std::vector<int> operators) 
или добавить в класс Client поле bool isOperator и проверять его.
При создании канала (в JOIN) сделать первого клиента оператором.
В CommandHandler для команд вроде KICK проверять, есть ли у клиента права оператора в этом канале, прежде чем выполнять действие.
Реализовать команды операторов, чтобы они работали только для тех, у кого есть права.

Когда клиент отправляет KICK #channel nick, сервер должен проверить, есть ли у отправителя статус оператора в канале #channel. 
Если нет — отправить ошибку вроде :server 482 nick #channel :You're not channel operator.



#### 1. Класс `Channel`
**Что сделано правильно:**
- Хранит имя канала и список участников (в виде сокетов), что соответствует базовой структуре IRC-канала.
- Метод `join` добавляет клиента в канал, только если его там нет, что предотвращает дублирование.
- Методы-геттеры (`getName`, `getMembers`) реализованы корректно и возвращают нужные данные.

**Что нужно исправить:**
- Нет проверки на максимальное количество участников (режим `l` из `MODE`), хотя это связано с отсутствием поддержки режимов канала.

**Что нужно добавить:**
- Поддержка операторов канала (например, список сокетов операторов).
- Поддержка режимов канала (`i`, `t`, `k`, `o`, `l`), как указано в задании (invite-only, topic restrictions, key, operator privileges, user limit).
- Пароль канала (режим `k`) и метод для его проверки при входе.
- Метод для удаления клиента из канала (например, при `KICK` или выходе).
- Возможность задавать и получать тему канала (`TOPIC`).

**Рекомендации по улучшению:**
- Добавить структуру или класс для хранения режимов канала (например, `struct Modes` с полями для `i`, `t`, `k`, `o`, `l`).
- Использовать `std::set` вместо `std::vector` для `members`, чтобы упростить проверку уникальности и удаление.
- Реализовать методы для управления участниками (добавление/удаление операторов, исключение клиентов).

---

#### 2. Класс `Client`
**Что сделано правильно:**
- Хранит сокет, никнейм, имя пользователя, буферы ввода-вывода и статус аутентификации — это соответствует базовым потребностям IRC-клиента.
- Методы-геттеры и сеттеры реализованы корректно, включая управление буферами.
- Поддержка пароля с ограничением попыток — логичное дополнение к заданию.

**Что нужно исправить:**
- Метод `eraseOutputBuffer` не проверяет, превышает ли `bytes` размер буфера, что может привести к некорректному поведению.

**Что нужно добавить:**
- Признак оператора (например, `bool isOperator`), чтобы различать операторов и обычных пользователей.
- Список каналов, в которых состоит клиент, чтобы упростить управление (например, `std::vector<std::string>`).
- Поддержка "реального имени" (realname), которое требуется в команде `USER` по стандарту IRC.

**Что убрать или что запрещено:**
- Использование `sprintf` в других классах для формирования строк с данными клиента — это C-функция, лучше заменить на `std::stringstream` для соответствия C++.

**Рекомендации по улучшению:**
- Добавить проверку валидности никнейма (например, длина, допустимые символы) в `setNickname`.
- Сделать буферы более гибкими для обработки больших сообщений (например, ограничить их размер и добавить обработку переполнения).
- Хранить временные данные (например, время подключения) для возможных будущих функций.

---

#### 3. Класс `CommandHandler`
**Что сделано правильно:**
- Обрабатывает команды `NICK`, `USER`, `JOIN`, `PRIVMSG`, `QUIT`, что частично соответствует заданию.
- Реализована аутентификация по паролю с ограничением попыток.
- Метод `broadcastMessage` корректно рассылает сообщения участникам канала, исключая отправителя.
- Использует ссылку на `Server`, что позволяет взаимодействовать с клиентами и каналами.

**Что нужно исправить:**
- Обработка `PRIVMSG` не различает личные сообщения и сообщения в канал — нужно добавить проверку, является ли цель (`target`) каналом или пользователем.
- В `processCommand` при обработке пароля используется `rfind("PASS ", 0)`, но это не стандарт IRC — клиенты обычно отправляют просто `PASS <password>`.
- Повторная отправка пароля после авторизации игнорируется, но лучше отправить клиенту сообщение об ошибке.

**Что нужно добавить:**
- Поддержка команд операторов: `KICK`, `INVITE`, `TOPIC`, `MODE` с соответствующими режимами (`i`, `t`, `k`, `o`, `l`).
- Проверка прав оператора перед выполнением операторских команд.
- Обработка ошибок для всех команд в соответствии со стандартом IRC (больше кодов ошибок, например, `432` для неверного никнейма).

**Что убрать или что запрещено:**
- Использование `sprintf` для формирования ответов — лучше использовать `std::stringstream` для большей безопасности и переносимости.

**Рекомендации по улучшению:**
- Разделить обработку команд на отдельные методы (например, `handleNick`, `handleJoin`) для читаемости и легкости добавления новых команд.
- Добавить логирование всех команд в файл или консоль для отладки.
- Улучшить обработку строк: используй функции вроде `std::string::substr` с проверками границ.

---

#### 4. Класс `Config`
**Что сделано правильно:**
- Хранит порт и пароль, проверяет их валидность при создании объекта (порт в диапазоне 1–65535, пароль не пустой).
- Простые геттеры корректно возвращают данные.

**Что нужно добавить (по заданию - не обЯЗАТЕЛЬНО):**
- Возможность задавать дополнительные параметры (например, максимальное число клиентов или тайм-аут).

**Что убрать или что запрещено:**
- Ничего запрещенного нет.

---

#### 5. Класс `Server`
**Что сделано правильно:**

1. **Использование `poll()`**:
   - В `run()` используется `poll()` для отслеживания событий на серверном и клиентских сокетах (`POLLIN` и `POLLOUT`), что полностью соответствует заданию.
   
2. **Неблокирующий режим**:
   - В `setupSocket()` серверный сокет устанавливается в неблокирующий режим через `fcntl(m_serverSocket, F_SETFL, O_NONBLOCK)`.
   - В `handleNewConnection()` то же самое делается для клиентских сокетов: `fcntl(clientSocket, F_SETFL, O_NONBLOCK)`. Все сокеты корректно настроены.

3. **Поддержка нескольких клиентов**:
   - Используется `std::vector<pollfd> fds` для отслеживания всех сокетов и `std::map<int, Client> m_clients` для хранения клиентов. Это позволяет обрабатывать множество подключений одновременно.
   - `handleNewConnection()` добавляет новых клиентов, а `removeClient()` корректно их удаляет.

4. **Обработка сигналов**:
   - В `initialize()` настроен обработчик SIGINT через `signal(SIGINT, Server::signalHandler)`, и флаг `shouldStop` позволяет выйти из цикла `run()`.
   - После SIGINT предлагается выбор: завершение (`shutdown()`) или перезапуск (`restart()`), что даже больше, чем требуется (graceful shutdown уже есть).

5. **Отсутствие запрещенных функций**:
   - Не используются `select()`, `fork()`, `system()` или другие запрещенные функции. Все операции ввода-вывода идут через `poll()`, `read()`, `send()`, что соответствует заданию.

6. **Пересылка данных через буферы**:
   - В `handleClientData()` данные от клиентов читаются в буфер, обрабатываются через `cmdHandler`, а ответы отправляются через `Client::appendOutputBuffer()` и `send()`. Это обеспечивает асинхронность.

7. **Graceful shutdown**:
   - В `shutdown()` закрываются все клиентские сокеты, серверный сокет и очищаются контейнеры (`m_clients`, `channels`), что предотвращает утечки ресурсов.

---

#### Что нужно исправить:
1. **Проверка на переполнение вектора `fds`**:
   - В задании не указано конкретное ограничение на число клиентов, но система имеет лимит на количество открытых файловых дескрипторов (обычно 1024 по умолчанию в Linux). В `handleNewConnection()` добавляется новый `pollfd` в `fds` без проверки, не превышает ли `fds.size()` системный лимит.
   - **Что сделать**: Добавить проверку перед `fds.push_back(clientFd)`:
     - Использовать `sysconf(_SC_OPEN_MAX)` для получения максимального числа дескрипторов.
     - Если `fds.size() >= max_fds`, отклонять новое соединение (закрывать `clientSocket` и логировать ошибку).

#### Что нужно добавить:
1. **Поддержка операторов и их прав в каналах**:
   - В задании требуется поддержка операторов каналов (команды вроде `KICK`, `INVITE`, `TOPIC`, `MODE`). Сейчас в классе `Server` есть `std::vector<Channel> channels`, но нет логики для управления операторами.
   - **Что сделать**: 
     - Добавить в `Server` метод или поле для хранения списка операторов (например, в `Channel` должен быть список операторов, а `Server` должен предоставлять доступ к этой информации через `CommandHandler`).
     - Это частично зависит от класса `Channel`, но `Server` должен передавать данные о каналах в `cmdHandler` для обработки операторских команд. Можно сделать это как интерфейс (например, метод `getChannel()`), а потом добавить реализацию.

2. **Лимит на максимальное число клиентов**:
   - В задании не указан явный лимит, но это хорошая практика для сервера. Сейчас все клиенты принимаются без ограничений.
   - **Что сделать**: 
     - Добавить в `Config` параметр `maxClients` (например, по умолчанию 10 или 50).
     - В `handleNewConnection()` проверять `m_clients.size() < config.getMaxClients()` перед добавлением нового клиента. Если лимит достигнут, закрывать сокет и логировать отказ.

#### Рекомендации по улучшению (необязательно для задания, но полезно):
1. **Логирование всех событий с временными метками**:
   - Это полезно для отладки и анализа.
   - **Что сделать**: Добавить в вывод время (например, через `<ctime>` с функцией `time()` и `strftime()`). Например:
     ```
     time_t now = time(NULL);
     char timeStr[20];
     strftime(timeStr, sizeof(timeStr), "%Y-%m-%d %H:%M:%S", localtime(&now));
     std::cout << "[" << timeStr << "] New client connected: " << ...;
     ```

2. **Оптимизация цикла `poll()`**:
   - Сейчас `fds` — это `std::vector<pollfd>` с автоматическим выделением памяти. Однако при большом числе клиентов (сотни или тысячи) можно столкнуться с затратами на перевыделение памяти.
   - **Что сделать**: 
     - Использовать `fds.reserve(config.getMaxClients())` в начале `run()`, чтобы заранее выделить память под ожидаемое число клиентов и избежать лишних перевыделений.

3. **Уведомление клиентов перед завершением/перезапуском**:
   - В `shutdown()` и `restart()` сокеты закрываются без уведомления клиентов. Это работает, но не соответствует IRC-протоколу, где клиенты должны получать сообщение (например, "Server shutting down").
   - **Что сделать**: 
     - Перед `close()` в `shutdown()` и `restart()` пройтись по `m_clients`, отправить сообщение через `send()` (например, `:server NOTICE * :Server shutting down\r\n`), дождаться отправки (проверить `POLLOUT`) и только потом закрывать сокеты.

---

### Что уже идеально:
- **Graceful shutdown**: Реализован через `shutdown()` с закрытием всех сокетов и очисткой контейнеров.
- **Частичная отправка**: Исправлена в `handleClientData()` с учетом `EAGAIN` и частичной отправки.
- **Обработка SIGINT**: Полностью реализована с выбором завершения или перезапуска.

---

### Итог: что осталось сделать для класса `Server`
1. **Обязательно по заданию**:
   - Добавить поддержку операторов в каналах (интерфейс для передачи данных о каналах в `CommandHandler`).
   - Реализовать проверку на переполнение `fds` (системный лимит дескрипторов).

2. **Желательно для полноты**:
   - Добавить лимит на число клиентов через `Config`.
   - Улучшить логирование с временными метками.
   - Оптимизировать `fds` через `reserve`.
   - Добавить уведомления клиентам перед завершением/перезапуском.
  
---
  
### Правка для Irssi класс CommandHandler
// Было (строки 159–166):
```cpp
            client.setUsername(username);
            std::cout << "Client set username: " << username << "\n";
            if (!client.getNickname().empty()) {
                std::string response = ":server 001 " + client.getNickname() + " :Welcome to the IRC server " + client.getNickname() + "!\r\n";
                client.appendOutputBuffer(response);
                fds[i].events |= POLLOUT;
            } else {
                std::string response = ":server 451 * :Please set a nickname with NICK command first\r\n";
```

// Станет:
```cpp
            client.setUsername(username);
            std::cout << "Client set username: " << username << "\n";
            if (client.isPasswordEntered() && !client.getNickname().empty()) {
                std::string response = ":server 001 " + client.getNickname() + " :Welcome to the IRC server " + client.getNickname() + "!\r\n";
                client.appendOutputBuffer(response);
                fds[i].events |= POLLOUT;
            } else if (client.getNickname().empty()) {
                std::string response = ":server 451 * :Please set a nickname with NICK command first\r\n";
```
// Было (строки 125–128):
```cpp
                    client.setNickname(nickname);
                    std::cout << "Client set nickname: " + nickname + "\n";
                    std::string response = ":server 001 " + nickname + " :Nickname set\r\n";
                    client.appendOutputBuffer(response);
```
// Станет:
```cpp
                    client.setNickname(nickname);
                    std::cout << "Client set nickname: " + nickname + "\n";
                    // Ничего не отправляем, ждем USER для полной регистрации
```
